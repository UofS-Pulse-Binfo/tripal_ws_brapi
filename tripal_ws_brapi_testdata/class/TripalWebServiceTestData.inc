<?php
/**
 * Custom Calls - call that does not involve any data stored in a database table.
 */
class TripalWebServiceTestData {
  // Data array used as a map, sequence order when accessing tables.
  // @see .module
  private $testdata_source;
  // Absolute path to test data source (csv files).
  private $testdata_source_dir;
  // Request type - load, remove or summary.
  private $testdata_request;


  // Constructor.
  public function __construct($source) {
    // Set source array.
    $this->setTestdataSource($source);
    // Source csv files directory.
    $this->setTestdataDirectory();
  }

  /**
   * Set the data (csv files) source.
   * This source array contains information about
   * chado.table and corresponding dataset to be inserted.
   *
   * @param $source
   *   Array, data source array.
   */
  public function setTestdataSource($source) {
    if (is_array($source)) {
      $this->testdata_source = $source;
    }
  }

  /**
   * Set the directory of source data (csv files).
   */
  public function setTestdataDirectory() {
    $module = 'tripal_ws_brapi_testdata';

    $dir = $dir = drupal_get_path('module', $module);
    $source_dir = $dir . '/includes/raw-data/';

    if (is_dir($source_dir)) {
      $this->testdata_source_dir = $source_dir;
    }
  }

  /**
   * Fetch database id number of terms.
   *
   * @param $arr_terms
   *   An associative array where the key is the cv ontology and value is an array
   *   of terms identified to belong in the cv key.
   *
   * @return array
   *   CV id and Cvterm id number. cv information in CV key and terms information
   *   stored in TERM key.
   */
  public function registerTerm($arr_terms) {
    $ids = [];

    foreach($arr_terms as $cv => $terms) {
      // Fetch CV.
      $id = tripal_get_cv(['name' => $cv])
        ->cv_id;

      if ($id) {
        $cv_id = $id;
      }
      else {
        $cv_id = tripal_insert_cv($cv, $cv . ' definition')
          ->cv_id;
      }

      // Save cv and and fetch terms in a cv.
      $ids[ $cv ]['cv'][ $cv ] = $cv_id;

      foreach($terms as $term) {
        if ($term && $cv_id) {
          $id2 = tripal_get_cvterm(['name' => $term, 'cv_id' => $cv_id])
            ->cvterm_id;

          if ($id2) {
            $cvterm_id = $id2;
          }
          else {
            $id2 = tripal_insert_cvterm([
              'id' => $cv . ':' . $term,
              'name' => $term,
              'cv_name' => $cv,
              'definition' => $term . ' definition',
            ])
              ->cvterm_id;
          }

          $ids[ $cv ]['term'][ $term ] = $id2;
        }
      }
    }

    return $ids;
  }

  /**
   * Fetch cv and cvterm id from terms id array.
   *
   * @param $term
   *  String, term to search in the id array.
   *
   * @param $ids
   *  Array, cv and cvterm ids generated by function in @dependencies.
   * @param $cvs
   *  Array, cv names associated to a term in a prop csv file.
   *
   * @return array
   *   Cv id and cvterm id number of cv id when term is a cv name.
   *
   * @dependencies
   *   tripal_ws_testdata_register_terms().
   */
  public function translateTerm($term, $ids, $cvs = null) {
    $result = '';

    foreach($ids as $cv => $sections) {
      if ($cv == $term) {
        // Return cv id.
        $result = $sections[ 'cv' ][ $cv ];
        break;
      }
      else {
        // Search term in term section key of the ids array.
        foreach($sections['term'] as $cvterm => $cvterm_id) {
          if ($cvterm == $term) {
            $result = $cvterm_id;

            if (is_null($cvs) || $cvs == $cv) {
              break 2;
            }
          }
        }
      }
    }

    return $result;
  }

  /**
   * Fetch inserted id of a value from a previous insert query.
   * Ids are stored in an array that keeps a record of insert request
   * for any subsequent reference.
   *
   * @param $value
   *   Search key, value in a csv file that was previously inserted and
   *   a request for id is made.
   * @param $ids;
   *   Cache, ids array maintained by each insert query.
   *
   * @return
   *   Id number of the value.
   */
  public function translateValue($value, $ids) {
    foreach($ids as $section => $val) {
      foreach($val as $term => $id) {
        if ($term == $value) {
          return $id;
        }
      }
    }
  }

  /**
   * Carry out action based on request.
   *
   * @param $request
   *   String, request to load, remove or summarize test data.
   * @param $optons
   *   Additional options that can be applied to requests.
   */
  public function doRequest($request, $options = null) {
    switch($request) {
      case 'load':
        // Test data in.
        $this->testdataLoad($options);
        break;

      case 'remove':
        // Test data out.
        $this->testdataRemove($options);
        break;

      case 'summary':
        // Test data summary.
        return $this->testdataSummary($options);
    }
  }
  ///////////


  /**
   * Load test data.
   *
   * @param $options
   *   Additional options to apply to this request.
   */
  public function testdataLoad($options = null) {
    $source = $this->testdata_source;
    $dir    = $this->testdata_source_dir;

    $TRANSACTION = db_transaction();
    try {
      foreach($source as $section => $items) {
        // To prevent potential data duplication, only allow on an empty table.
        $has_data = 0;

        if ($section != 'cvterm') {
          $has_data = chado_query(sprintf("SELECT * FROM {%s} LIMIT 1", $section))
            ->rowCount();
        }

        if ($has_data) {
          drupal_set_message('Could not install test data, please delete records in CHADO '. $section . ' and try again', 'error', FALSE);
          return 0;
        }

        // Begin insert.
        // Each section - project, stock..., pre-install terms required when
        // inserting into primary tables. Property rows will insert another
        // set but are handled in if block (equals prop) below and are the
        // header row of the csv file.

        // Pre-install terms for primary tables.
        $f = $dir . $section . '/terms.php';
        if (file_exists($f)) {
          include_once($f);
          $main_ids = $this->registerTerm($terms);
        }

        foreach($items as $table => $datafile) {
          $handle = fopen($dir . $section . '/' . $datafile . '.csv', 'r');

          if ($handle !== FALSE) {
            $i = 0;

            while(!feof($handle)) {
              $row  = fgets($handle);
              $data = str_getcsv($row, ",");
              $data = array_map('trim', $data);

              if (!empty($data) && strlen($row) > 0) {
                if ($section == 'cvterm' && $i > 0) {
                  // Insert terms only - cv and cvterms.
                  // Name, definition, Controlled Vocabulary.
                  tripal_insert_cvterm(
                    [
                      'id' => $data[2] . ':' . $data[0],
                      'name' => $data[0],
                      'cv_name' => $data[2],
                      'definition' => $data[1] . ' definition',
                    ]
                  );
                }
                elseif ($i == 0) {
                  // Is the header. This is the header row, the first row in a csv
                  // file. In most cases it reflects the field name of the table
                  // it is trying to insert record into.

                  // If the request is to insert into property table, the first item
                  // (header) contains the record previously inserted so that there is
                  // a one to one match ie. project to projectprop, thus translate key
                  // preceeds the header to indicate that it has to resolve. The rest
                  // of the header is the type_id/cvterm_id representive a value in the
                  // prop table.
                  if ($table == 'prop') {
                    $ids = [];
                    $new_data = [];

                    foreach($data as $j => $cell) {
                      if ($j == 0) continue; // Is the referenced object.

                      @list($cv, $cvterm) = explode(':', $cell);
                      $arr_terms[$cv][] = $cvterm;

                      $new_data[] = $cvterm;
                      // Save cvs matching the term to allow for exact search
                      // when identical term is reference but from a different cvs.
                      $cvs[]      = $cv;
                    }

                    // Register all terms.
                    $prop_ids = $this->registerTerm($arr_terms);
                    unset($data);
                    $header = $new_data;
                  }
                  else {
                    $header = $data;
                  }
                }
                else {
                  // Lines. Rows after the header rows will be added to the table.
                  if ($table == 'prop') {
                    // Property tables.
                    $line = [];
                    $row_id = '';

                    foreach($data as $j => $cell) {
                      if ($j == 0) {
                        // Primary key/field.
                        $row_id = $this->translateValue($cell, $property_id);
                        continue;
                      }

                      // Installing a property, ensure an exact term search - with the cv
                      // to use the term defined in the csv file (header row), in case or multiple identical terms.
                      if ($cell != '') {
                        $type_id = $this->translateTerm($header[ $j - 1 ], $prop_ids, $cvs[ $j - 1 ]);
                        $line = [
                          // Less 1 in header key to account skip in if -- continue above.
                          $section . '_id' => $row_id,
                          'value'   => $cell,
                          'type_id' => $type_id
                        ];

                        // Insert property.
                        chado_insert_record($section . 'prop', $line);
                      }
                    }
                  }
                  else {
                    // Main table and auxilary tables.
                    $line = [];
                    for ($j = 0; $j < count($header); $j++) {
                      $col = '';
                      $val = '';

                      // Header has translate command.
                      @list($translate, $field) = explode(':', $header[ $j ]);
                      if ($translate == 'translate_term' || $translate == 'translate_value') {
                        if ($translate == 'translate_term') {
                          $term = $this->translateTerm($data[ $j ], $main_ids);
                          $val = $term;
                        }
                        else {
                          // Previous section.
                          $term = $this->translateValue($data[ $j ], $property_id);
                          $val = $term;
                        }

                        $col = trim($field);
                      }
                      else {
                        $val = $data[ $j ];
                        $col = $header[ $j ];
                      }

                      $line[ $col ] = $val;
                    }

                    // Save row to main table, non-prop table and save ids for
                    // prop table (translate headers).

                    // Uses db_insert - chado_insert fires an error when inserting
                    // into a chado member table that has been altered - ie: phenotype
                    // @see .install.
                    $relation = ($table == 'main') ? $section : $table;
                    $inserted_id = db_insert('chado.' . $relation)
                      ->fields($line)
                      ->execute();

                    // First item in the data is the key used in prop.
                    if ($table == 'main') {
                      $property_id[ $section ][ $data[0] ] = $inserted_id;
                    }
                  }
                }
              }

              $i++;
            }
          }

          fclose($handle);
        }
      }
    }
    catch (Exception $e) {
      $TRANSACTION->rollback();
      exit();
    }
  }

  /**
   * Remove test data.
   *
   * @param $options
   *   Additional options to apply to this request.
   *
   * NOTE: all terms used - cvterms stay.
   */
  public function testdataRemove($options = null) {
    $source = array_reverse($this->testdata_source);
    $dir    = $this->testdata_source_dir;

    foreach($source as $section => $items) {
      foreach($items as $table => $datafile) {
        if ($table == 'main') {
          $handle = fopen($dir . $section . '/' . $datafile . '.csv', 'r');

          $i = 0;
          while(!feof($handle)) {
            $row  = fgets($handle);
            $data = str_getcsv($row, ",");

            if($i == 0) {
              // Of type _relationship, use the type_id to remove the set.
              if (strpos($section, 'relationship') !== FALSE) {
                // Locate the type_id from csv.
                foreach($data as $j => $field_name) {
                  // Remove any replacement command.
                  $f = str_replace(['translate_value:', 'translate_term:'], '', $field_name);
                  if (trim($f) == 'type_id') {
                    $field_i = $j;
                    break;
                  }
                }

                $tmp_field = 'type_id';
              }
              else {
                // Otherwise, use the first item in the csv as the key.
                $tmp_field = $data[0];
              }

              $field = trim($tmp_field);
            }
            else {
              $sql = "DELETE FROM {%s} WHERE %s = :field_value";
              $query = sprintf($sql, $section, $field);

              if (isset($field_i)) {
                $field_value = tripal_get_cvterm(['name' => trim($data[ $field_i ])])
                  ->cvterm_id;
              }
              else {
                $field_value = trim($data[0]);
              }

              chado_query($query, [':field_value' => $field_value]);
            }

            $i++;
          }
        }
      }
      unset($field_i);
      fclose($handle);
    }
  }

  /**
   * Create test data summary table.
   *
   * @param $options
   *   Additional options to apply to this request.
   *
   * @return array
   *   Array, can be rendered as Drupal form objects.
   *     - Drupal set message
   *     - Button
   *     - Tabs
   */
  public function testdataSummary($options) {
    $source = $this->testdata_source;
    $dir    = $this->testdata_source_dir;
    // Sort only applies to the first item of the primary table.
    // ie: project name, stock name, phenotype uniquename.

    // When no sort, default to the order in the csv file.
    $sort   = $options['sort'];


    $i = 0;
    $tab = '';
    $tab_page = $table = [];

    // Array to hold data to check if data has been loaded.
    $data_check = [];

    foreach($source as $section => $items) {
      $title = strtoupper($section);
      $tab .= '<li><a href="#fragment-' . $i . '">' . $title . '</a></li>';

      foreach($items as $table => $datafile) {
        $source_file = $dir . $section . '/' . $datafile . '.csv';
        $handle = fopen($source_file, 'r');

        if ($handle !== FALSE) {
          $j = 0;
          $header = [];
          $rows   = [];

          while(!feof($handle)) {
            $row  = fgets($handle);
            $data = str_getcsv($row, ",");

            if (strlen($row) > 0) {
              if ($j == 0) {
                // Header.
                $data = array_map(function($v) {
                  // Remove commands: translate_term and translate_value.
                  @list($command, $title) = explode(':', $v);
                  $col_title = (isset($title)) ? $title : $command;
                  return strtoupper($col_title);

                }, $data);

                $header = $data;
              }
              else {
                // Data.

                // Item saved to check. See command button.
                if ($section == 'project' && $j == 1) {
                  $data_check[ $section ][ $header[0] ] = $data[0];
                }

                $rows[] = $data;
              }
            }

            $j++;
          }
        }

        fclose($handle);

        // Sort.
        if ($sort == 'asc' || $sort == 'desc') {
          $sort_key = array_column($rows, 0);

          if ($sort == 'asc') {
            array_multisort($sort_key, SORT_ASC, $rows, SORT_STRING);
          }
          else {
            array_multisort($sort_key, SORT_DESC, $rows, SORT_STRING);
          }
        }
        // Else, default to the order it appears in the csv file.

        $download_csv = l('Source file: download CSV', $source_file, ['target' => '_blank']);
        $source_table = ($table == 'main' || $table == 'prop') ? $section : $table;

        $summary_table[ $title ][] = '[' . $source_table . ']<div class="tripal-ws-brapi-download-link">' . $download_csv . '</div>'
          . theme('table', ['header' => $header, 'rows' => $rows, 'empty' => t('0 data')]);
      }

      $tab_page[] = '<div id="fragment-' . $i . '"><h2>' . $title . ' & Property table</h2>' . implode('', $summary_table[ $title ]) . '</div>';
      $i++;
    }

    drupal_get_messages(null, TRUE);
    $asc  = l('a-z', 'tripalwsbrapi/testdata?sort=asc');
    $desc = l('z-a', 'tripalwsbrapi/testdata?sort=desc');
    $none = l('none', 'tripalwsbrapi/testdata');

    $prop_summary = '<br /><div class="tripal-ws-brapi-context-link">Sort: ' . $none . ' | ' . rawurldecode($asc) . ' | ' . rawurldecode($desc) . '</div><div id="tabs"><ul id="tripal-ws-brapi-tabs">' . $tab . '</ul>' . implode('', $tab_page) . '</div>';

    // Inspect the projects table to see if a single row in the csv
    // file was added would suffice to indicate that load has been
    // executed, rename the button to remove test data.

    // First item prepared when constructing the summary table above.
    $check_table = array_keys($data_check);
    $check_field = array_keys($data_check[ $check_table[0] ]);
    $check_value = $data_check[ $check_table[0] ][ $check_field[0] ];
    $check_field = strtolower($check_field[0]);

    $query = sprintf("SELECT %s FROM {%s} WHERE %s = :value LIMIT 1", $check_field, $check_table[0], $check_field);
    $check = chado_query($query, [':value' => $check_value])
      ->fetchField();

    $prop_button_label = ($check) ? 'Remove Test Data' : 'Load Test Data';
    $prop_message      = ($check) ? 'Click button to revert test data in CHADO.'
      : 'No test data in chado tables. Click button to load test data.';

    return ['summary' => $prop_summary, 'button' => $prop_button_label, 'message' => $prop_message];
  }
  ///
}
